{
  "project": "Agent-NN MCP Modernization",
  "objective": "Schrittweise Umstellung auf eine Modular Control Plane Architektur",
  "model": "gpt-4",
  "approvalMode": "full-auto",
  "fullAutoErrorMode": "ignore-and-continue",
  "notify": false,
  "phases": [
    {
      "name": "MCP Phase 1: Architektur-Blueprint",
      "description": "Grundstruktur f\u00fcr die Microservice-Architektur festlegen und Platzhalter-Dienste anlegen.",
      "tasks": [
        {"id": "M1T1", "description": "Schnittstellen und Service-Grenzen definieren."},
        {"id": "M1T2", "description": "Ordnerstruktur f\u00fcr Dispatcher, Registry und Worker-Services anlegen."},
        {"id": "M1T3", "description": "Basis-Docker-Compose f\u00fcr neue Dienste erstellen."}
      ],
      "exitCriteria": "Blueprint und Skeleton-Dienste laufen lokal miteinander."
    },
    {
      "name": "MCP Phase 2: Kernservices",
      "description": "Task-Dispatcher, Agent-Registry und Session-Manager mit erster Logik f\u00fcllen.",
      "tasks": [
        {"id": "M2T1", "description": "Agent-Registry mit statischer Konfiguration implementieren."},
        {"id": "M2T2", "description": "Dispatcher nutzt Registry zur Agentenwahl."},
        {"id": "M2T3", "description": "Session-Verwaltung \u00fcber Redis bereitstellen."}
      ],
      "exitCriteria": "Dispatcher kann eine Testanfrage \u00fcber Registry an einen Dummy-Worker weiterleiten."
    },
    {
      "name": "MCP Phase 3: Wissens- und LLM-Services",
      "description": "Vector-Store-Service und LLM-Gateway aufbauen; Worker-Services aus dem Monolithen herausl\u00f6sen.",
      "tasks": [
        {"id": "M3T1", "description": "Vector-Store-Service mit REST-API implementieren."},
        {"id": "M3T2", "description": "LLM-Gateway f\u00fcr OpenAI und lokale Modelle bereitstellen."},
        {"id": "M3T3", "description": "Erste Worker-Services (Dev, OpenHands, LOH) auslagern."}
      ],
      "exitCriteria": "Dispatcher greift auf Vector-Store und LLM-Service zu; mindestens ein Worker-Service arbeitet eigenst\u00e4ndig."
    },
    {
      "name": "MCP Phase 4: Integration & Messaging",
      "description": "Asynchrone Kommunikation und API-Gateway erg\u00e4nzen; CLI/API auf neue Dienste umstellen.",
      "tasks": [
        {"id": "M4T1", "description": "Message-Queue (Redis/Kafka) f\u00fcr Dispatcher \u2192 Worker einrichten."},
        {"id": "M4T2", "description": "API-Gateway vor die Services schalten."},
        {"id": "M4T3", "description": "CLI und bestehende API an Dispatcher anbinden."}
      ],
      "exitCriteria": "End-to-End-Flow \u00fcber Queue und Gateway funktioniert stabil."
    },
    {
      "name": "MCP Phase 5: Abschluss & Deployment",
      "description": "Dokumentation aktualisieren und Container-Deployment vorbereiten.",
      "tasks": [
        {"id": "M5T1", "description": "Architekturdokumente und README auf MCP-Stand bringen."},
        {"id": "M5T2", "description": "Docker-Compose/Helm f\u00fcr alle Services bereitstellen."},
        {"id": "M5T3", "description": "Roadmap abschlie\u00dfen und Ausblick notieren."}
      ],
      "exitCriteria": "Alle Dienste laufen containerisiert; Doku reflektiert finalen MCP-Aufbau."
    }
  ],
  "autoPhaseSwitch": true,
  "progressLog": "codex_progress.log"
}
